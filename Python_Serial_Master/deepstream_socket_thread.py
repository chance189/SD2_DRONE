'''
* Author: Chance Reimer
* Purpose: Create python thread that will poll the ZMQ socket generated by the Deepstream SDK
* 	   The thread will grab information, package them in a detection class, and pass them
*	   to the main thread. 
* Note: queue library standard in python is thread safe, all mutex and or sematophore are A okay
'''
import threading
import time
import zmq                   #for socket
import detect_pipe_pb2       #protobuffer unpacking
import detections            #We need way to store and send value down queue
import queue

class deepstream_socket_thread(threading.Thread):
    #Initialize the socket thread, requires an instance of the queue needed to send info
    #To the main thread
    def __init__(self, info_pipe):
        threading.Thread.__init__(self)
        self.pipe = info_pipe
        self.init_socket()
        self.isInit = False
        self.proto_data = detect_pipe_pb2.DETECTION()
    
    def init_socket(self):
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.PULL)
        port = "5555"
        self.socket.connect("tcp://localhost:%s" % port)
        self.poll = zmq.Poller()
        self.poll.register(self.socket)
        print("Socket Initialized")

    def run(self):
        print("In Run Socket")
        #context = zmq.Context()
        #socket = context.socket(zmq.PULL)
        #socket.connect("tcp://localhost:5555")
        #poll = zmq.Poller()
        #poll.register(socket)
        while(True):
            if self.socket in dict(self.poll.poll(0)):
                data = self.socket.recv()
                self.proto_data.ParseFromString(data)
                print("Received info packet in socket thread")
                detection_obj = detections.detections(x=self.proto_data.x,
                        y=self.proto_data.y, h=self.proto_data.h, w=self.proto_data.w,
                        label=self.proto_data.label, 
                        timeStamp=time.time())
                self.pipe.put(detection_obj)

    def get_id(self):
        if hasattr(self, '_thread_id'):
            return self._thread_id

        #case that we dont' have an id set
        for id, thread in threading._active.items():
            if thread is self:
                return id
    
    #make sure to run join after calling this function
    def omg_kill_urself(self):
        thread_id = self.get_id()
        result = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, ctypes.py_object(SystemExit))
        if result > 1:
            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, 0)
            print("Attempt to Raise Exception Failed:\nSource: Deepstream_Socket\nDiagnosis: FATAL")
	
